<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wang-y.github.io</id>
    <title>咩技术的技术Blog</title>
    <updated>2019-07-06T15:36:43.913Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wang-y.github.io"/>
    <link rel="self" href="https://wang-y.github.io/atom.xml"/>
    <subtitle>不仅不知新，并且还经常忘旧o( ╯□╰ )o</subtitle>
    <logo>https://wang-y.github.io/images/avatar.png</logo>
    <icon>https://wang-y.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 咩技术的技术Blog</rights>
    <entry>
        <title type="html"><![CDATA[垃圾回收]]></title>
        <id>https://wang-y.github.io/post/lajihuishou</id>
        <link href="https://wang-y.github.io/post/lajihuishou">
        </link>
        <updated>2019-07-06T13:53:59.000Z</updated>
        <summary type="html"><![CDATA[<p>如果Java虚拟机创建的对象无论是否被使用都不会得到释放从而占满了所有的内存空间，那么在创建新的对象时，将会产生OutOfMemoryException。</p>
]]></summary>
        <content type="html"><![CDATA[<p>如果Java虚拟机创建的对象无论是否被使用都不会得到释放从而占满了所有的内存空间，那么在创建新的对象时，将会产生OutOfMemoryException。</p>
<!-- more -->
<p>所以Java虚拟机有一套自动内存管理机制，叫做垃圾回收机制。</p>
<p>对象的是否需要进行回收，需要进行判断，判断的方式有两种：</p>
<p><strong>引用计数法</strong></p>
<p>当对象每被引用一次时，其引用计数器加一；当其中一个引用失效时，其引用计数器减一，当对象的引用计数器值为零时，标记此对象可以被清除。</p>
<p>优点：</p>
<ul>
<li>判定效率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>当两个对象循环引用时，计数器便无法标记为0，于是导致两个对象不会被回收。</li>
</ul>
<p><strong>可达性分析</strong></p>
<p>从一个根节点向下搜索，搜索的路径被称作引用链，当一个对象到根节点没有任何引用链相连时，则证明此对象是不可达的，标记次对象可以被清除。</p>
<p>优点：</p>
<ul>
<li>更加精确和严谨，可以分析出循环数据结构相互引用的情况</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现比较复杂</li>
<li>需要分析大量数据，消耗大量时间</li>
<li>分析过程需要GC停顿（引用关系不能发生变化），即停顿所有Java执行线程（称为&quot;Stop The World&quot;，是垃圾回收重点关注的问题）</li>
</ul>
<p>可达性分析法中的根叫做GC Roots。</p>
<p>在Java中，能够当作GC Roots的有：</p>
<ul>
<li>VM Stack中Stack Frame的局部地变量表引用的对象</li>
<li>方法区/元空间中的静态属性引用的对象</li>
<li>方法区/元空间中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<p>目前所有的Java虚拟机中都采用可达性分析法来判断对象是否需要被清除。</p>
<h1 id="垃圾回收算法">垃圾回收算法</h1>
<h2 id="标记-清除算法">标记-清除算法</h2>
<p>首先遍历GC Roots标记出存活对象，然后再次遍历所有对象，将没有被标记为存活的对象清除。</p>
<p>缺点：效率低，且容易产生内存碎片，如果新的对象无法找到合适的连续空间进行存储，将会触发GC。</p>
<h2 id="复制算法">复制算法</h2>
<p>将内存区等分为两个区域，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。当活动区间被占满时，将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。在空间转换的同时垃圾对象被一次性清除。</p>
<p>优点：无内存碎片；</p>
<p>缺点：可用内存减少一半，降低性能。</p>
<h2 id="标记-整理算法">标记-整理算法</h2>
<p>首先遍历GC Roots标记出存活对象，然后再次遍历所有对象，移动存活对象按照内存地址依次排列，最后，将末端内存地址以后的内存全部回收。</p>
<p>优点：</p>
<ul>
<li>产生较少的内存碎片</li>
<li>消除了复制算法中内存减半额高额待见</li>
</ul>
<p>缺点：效率低</p>
<h1 id="垃圾收集器">垃圾收集器</h1>
<h2 id="serial-gc">Serial GC</h2>
<p>单线程串行垃圾收集器，新生代使用复制算法，老年代使用标记-整理算法。</p>
<p>Stop The Word时间长。</p>
<h2 id="parnew-gc">ParNew GC</h2>
<p>多线程串行垃圾收集器，Serial GC的多线程版本，新生代使用复制算法，老年代使用标记-整理算法。</p>
<p>Stop The Word时间相对Serial GC较短，但在单线程环境中不一定表现比Serial GC更好。</p>
<h2 id="parallel-scavenge-gc">Parallel Scavenge GC</h2>
<p>并行清除垃圾收集器，是一个新生代收集器，采用复制算法，其关注点并非尽可能的降低STW时间，而是旨在达到一个可以控制的吞吐量。</p>
<p>吞吐量指的是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。</p>
<h2 id="serial-old-gc">Serial Old GC</h2>
<p>单线程老年代串行垃圾收集器，Serial GC的老年代版本，是一个老年代收集器，老年代采用标记-整理算法。</p>
<h2 id="parallel-old-gc">Parallel Old GC</h2>
<p>并行清除老年代垃圾收集器，Parallel Scavenge GC的老年代版本，是一个老年代收集器，使用多线程和标记-整理算法。</p>
<h2 id="concurrent-mark-sweep-gc">Concurrent Mark Sweep GC</h2>
<p>并发标记清除垃圾收集器，是使用标记-清除算法的老年代收集器。</p>
<p>工作时主要分为四个步骤：</p>
<ol>
<li>初始标记(单线程，STW)</li>
<li>并发标记(同用户线程一起工作)</li>
<li>重新标记(并行，STW)</li>
<li>并发清除(同用户线程一起工作)</li>
</ol>
<p>问题：</p>
<ul>
<li>CPU资源敏感</li>
<li>无法处理浮动垃圾</li>
<li>易产生内存碎片</li>
</ul>
<h2 id="garbage-first-gc">Garbage First GC</h2>
<p>简称G1垃圾收集器，非实时收集器。</p>
<p>特点：</p>
<ul>
<li>并行并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ul>
<p>工作时分为四个步骤：</p>
<ol>
<li>初始标记(单线程，STW)</li>
<li>并发标记(同用户线程一起工作)</li>
<li>最终标记(并行)</li>
<li>筛选回收(并行)</li>
</ol>
<p>在G1垃圾收集器中，采用了全新的内存布局，将Heap分成了一块块大小相等的Heap Region，一般在2000多块，Region在逻辑上时连续的，每个Region都会被打上唯一分代标记(eden,survivor,old)。在逻辑上，eden regions构成Eden空间，survivor regions构成Survivor空间，old regions构成了old 空间。</p>
<p>在并发标记时，G1会确定堆中对象的存活情况，标记完成后，G1知道哪些regions空闲空间多(可回收对象多)，优先回收这些空的regions，释放出大量的空闲空间。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存模型]]></title>
        <id>https://wang-y.github.io/post/jvmneicunmoxing</id>
        <link href="https://wang-y.github.io/post/jvmneicunmoxing">
        </link>
        <updated>2019-07-06T04:37:02.000Z</updated>
        <summary type="html"><![CDATA[<p>Java RunTime Data Area(Java 运行时数据区) 分为:</p>
<ul>
<li>Java Heap(Java堆)</li>
<li>Method Area(方法区) (Java 8 之前)</li>
<li>Meta Space(元空间) (Java 8 之后)</li>
<li>VM Stack(虚拟机栈)</li>
<li>Native Methiod Stack(本地方法栈)</li>
<li>Program Counter Register(程序计数器)。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>Java RunTime Data Area(Java 运行时数据区) 分为:</p>
<ul>
<li>Java Heap(Java堆)</li>
<li>Method Area(方法区) (Java 8 之前)</li>
<li>Meta Space(元空间) (Java 8 之后)</li>
<li>VM Stack(虚拟机栈)</li>
<li>Native Methiod Stack(本地方法栈)</li>
<li>Program Counter Register(程序计数器)。</li>
</ul>
<!-- more --> 
<p><img src="https://wang-y.github.io/post-images/1562387893493.png" alt=""></p>
<h1 id="java-heap">Java Heap</h1>
<p>Java创建的所有引用对象类型都存储在Heap中，所以此区域是所有线程共享的。</p>
<p>Heap中有分为:</p>
<ul>
<li>Old Gen(老年代)</li>
<li>Young Gen(新生代)</li>
<li>Eden Space(伊甸区)</li>
<li>Survivor Space(幸存者区)
<ul>
<li>From</li>
<li>To</li>
</ul>
</li>
</ul>
<p>因所有引用对象类型都存储在Heap区中，如果对象始终存在而不被清除，那么Heap内存将会被占满，导致内存溢出，所以Heap是垃圾收集的重点区域。</p>
<h1 id="method-areaperm-gen">Method Area/Perm Gen</h1>
<p>Java中被加载的类信息、常量、静态变量、即时编译器编译后的代码都存储在此区域中，所有此区域是所有线程共享的。</p>
<p>类信息包括：</p>
<ul>
<li>完整有效名称（全名=包名.类名）</li>
<li>直接父类的有效名称（java.lang.Object除外)</li>
<li>类的修饰符</li>
<li>接口的有序列表</li>
<li>域(field)信息</li>
<li>方法(method)信息</li>
</ul>
<p>常量及静态变量：</p>
<ul>
<li>static final 修饰的常量</li>
<li>static 修饰的变量</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>对于八种基本数据类型的静态变量会直接在方法区中开辟空间，并将其对应的值存储在方法区中</li>
<li>对于引用类型的静态变量如果未用new关键字为引用类型的静态变量分配对象（如: static Object obj;）那么对象的引用obj会存储在方法区中，并为其指定默认值null;</li>
<li>对于引用类型的静态变量如果用new关键字为引用类型的静态变量分配对象（如: static Person person = new Person();）,那么对象的引用person 会存储在方法区中，并且该对象在堆中的地址也会存储在方法区中（注意此时静态变量只存储了对象的堆地址，而对象本身仍在堆内存中）</li>
</ul>
<p>Method Area也经常被称作Non-heap(非堆)，但是在Hotspot中，其定义了Perm Gen(持久代)(仅在Hotspot中有持久代这个概念)，以此替代Method Area，也就是说在Hotspot中在物理上Method Area存在于Heap中的Perm Gen中，但是从逻辑上来讲，Method Area与Heap的概念还是互相独立的。</p>
<p>在Java7之前，字符串常量池和运行时常量池都存放在Method Area中。
到Java7时，字符串常量池被移到了Heap中。</p>
<p>Method Area也需要进行垃圾收集。</p>
<h1 id="meta-space">Meta Space</h1>
<p>Java8之后，移除了Method Area的概念，引入了新的Meta Space概念，这使得在原先从物理上占用Heap内存的Perm Gen的空间得到了释放，新的Meta Space将直接使用本地内存，使得类元数据只受到可用的本地内存限制(容量取决于是32位或是64位操作系统的可用虚拟内存大小)</p>
<p>在Java8之后，运行常量池被移到了Meta Space中，字符串常量池依然存放于堆中。</p>
<p>Meta Space也需要进行垃圾收集。</p>
<h1 id="vm-stack">VM Stack</h1>
<p>当方法被执行时，会同时创建一个Stack Frame(栈帧)。</p>
<p>Stack Frame内会记录:</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口</li>
</ul>
<p>每一个方法的执行，就代表这一个Stack Frame从入栈到出栈的过程，VM Stack被执行这个方法的线程单独持有，是私有的。</p>
<p>VM Stack的大小可以是固定的，也可以是动态调整的，如果大小被固定，一旦线程需要一个比较固定大小更大的VM Stack，将会发生 StackOverflowException；如果是动态调整的大小，一旦在动态拓展时没有足够的内存或者系统没有系统没有足够的内存为新线程创建Stack，将会发生OutOfMemoryExcption；</p>
<h1 id="native-methiod-stack">Native Methiod Stack</h1>
<p>本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、方法出口。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间。</p>
<p>也会抛出StackOverFlowError和OutOfMemoryError异常。</p>
<h1 id="program-counter-register">Program Counter Register</h1>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>Program Counter Register 正是这个用于记录当前线程正在执行的字节码的行号指示器。</p>
<p>此区域是Java规范中唯一没有规定任何OutOfMemoryExcption的区域。</p>
<p>如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p>
]]></content>
    </entry>
</feed>