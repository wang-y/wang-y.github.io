<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wang-y.github.io</id>
    <title>咩技术的技术Blog</title>
    <updated>2019-07-07T15:23:00.455Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wang-y.github.io"/>
    <link rel="self" href="https://wang-y.github.io/atom.xml"/>
    <subtitle>不仅不知新，并且还经常忘旧o( ╯□╰ )o</subtitle>
    <logo>https://wang-y.github.io/images/avatar.png</logo>
    <icon>https://wang-y.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 咩技术的技术Blog</rights>
    <entry>
        <title type="html"><![CDATA[类加载过程]]></title>
        <id>https://wang-y.github.io/post/lei-jia-zai-guo-cheng</id>
        <link href="https://wang-y.github.io/post/lei-jia-zai-guo-cheng">
        </link>
        <updated>2019-07-07T13:39:46.000Z</updated>
        <summary type="html"><![CDATA[<p>在编写代码时，编辑的文件名后缀为.java，我们需要将其编译成.class为后缀的文件，之后加载到虚拟机中才能被运行和使用。</p>
<p>那么类是如何被加载的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在编写代码时，编辑的文件名后缀为.java，我们需要将其编译成.class为后缀的文件，之后加载到虚拟机中才能被运行和使用。</p>
<p>那么类是如何被加载的呢？</p>
<!-- more -->
<p>类的加载过程一共分为7个阶段，如下图：</p>
<p><img src="https://wang-y.github.io/post-images/1562507092196.png" alt=""></p>
<h1 id="加载">加载</h1>
<p>首先，虚拟机需要通过类的全限定名才能获取到定义此类的二进制字节流。
然后，将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。
最后，在内存中生成一个代表该类的java.lang.Class对象，作为这个类在方法区的各种数据的访问入口。</p>
<p>虚拟机规范其实相对比较宽泛，并没有强制规范“二进制字节流一定要从.class文件中读取”，所以，也可使用很多其他的方式，诸如 压缩包内读取、网络上获取、其他文件生成、数据库中读取、运行时计算生成等。</p>
<h1 id="验证">验证</h1>
<p>验证的目的主要是为了校验.class文件中获取的二进制字节流中包含的信息是否满足当前虚拟机的要求，并且不会对当前虚拟机产生安全方面的危害。</p>
<p>主要包含4个方面的验证：</p>
<ol>
<li>文件格式验证(是否以魔数0xCAFEBABY开头、主次版本号是否在当前虚拟机处理范围内等)</li>
<li>元数据验证(是否有父类、父类是否继承了final修饰的类、如果非抽象类是否实现了其父类或者接口中所有要求的方法、是否重写了父类中final修饰的方法等)</li>
<li>字节码验证(通过数据流和控制流分析，判定程序语义是否是合法的、符合逻辑的；对方法体进行校验分析，却表被校验的类的方法在运行时不会做出危害虚拟机的安全事件。)</li>
<li>符号引用验证(符号引用中能否通过字符串描述的全限定名寻找到对应类；在指定的类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段；符号引用中的类、字段、方法的访问性是否允许被当前类访问；)</li>
</ol>
<h1 id="准备">准备</h1>
<p>在这一阶段中，将正式为类变量分配内存，并设置其初始值。</p>
<p><strong>注意</strong></p>
<p>所谓的类变量，仅指被“static”修饰的变量，而不包括实例变量。</p>
<h1 id="解析">解析</h1>
<p>在这一阶段中，虚拟机将常量池内的符号引用将转化为直接引用。</p>
<p>主要针对7类符号引用：</p>
<ol>
<li>类及接口</li>
<li>字段</li>
<li>类方法</li>
<li>接口方法</li>
<li>方法类型</li>
<li>方法句柄</li>
<li>调用点限定符</li>
</ol>
<h1 id="初始化">初始化</h1>
<p>Java虚拟机规范中强制定义了有且仅有5中情况必须立即对类进行初始化：</p>
<ol>
<li>遇到了new、getstatic、putstatic、invokestatic4条字节码指令时</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>初始化一个类时，其父类尚未被初始化，需要先触发其父类的初始化</li>
<li>虚拟机启动时，用户需要指定一个要执行的主类时(即main()方法的所在类)，虚拟机会先初始化这个类。</li>
<li>使用JDK 1.7的动态语言支持时</li>
</ol>
<p>到了这一步，才真正开始执行类中定义的Java程序代码。
通俗来说就是执行类构造器&lt;clinit&gt;()方法的过程。</p>
<h1 id="双亲委派模型">双亲委派模型</h1>
<p>对于Java虚拟机的角度来讲，只存在两种不同的类加载器:</p>
<ul>
<li>Bootstrap ClassLoader(启动类加载器)，由C++实现，是虚拟机自身的一部分</li>
<li>所有其他的类加载器，都是有Java语言实现，独立于虚拟机外部，并且都继承自抽象类java.lang.ClassLoader</li>
</ul>
<p>但是对于Java程序员来说，可以更细致一些：</p>
<ul>
<li>Bootstrap ClassLoader(启动类加载器) ：主要负责将存放于 JAVA_HOME/lib 目录下的，并且能够按文件名被虚拟机识别的类库加载到虚拟机中。</li>
<li>Extension ClassLoader(拓展类加载器) ：主要负责将存放于 JAVA_HOME/lib/ext 目录下的类库加载到虚拟机中。</li>
<li>Application ClassLoader(应用类加载器) ：主要负责将存放在用户路径(ClassPath)下的类库加载到虚拟机中。</li>
</ul>
<p>此三者类加载器互相配合进行加载，具有层级关系</p>
<p><img src="https://wang-y.github.io/post-images/1562511382768.png" alt=""></p>
<p>最后，程序员们可以在应用类加载器之下自定义类加载器。</p>
<p>双亲委派模型工作过程：
类加载器收到了类加载委托请求，它首先不会去尝试自己加载该类，而是委派给父类加载器去加载，如果父类加载器在其搜索范围内没有找到所需的类而无法完成这个加载请求时，子类加载器才会尝试由自己去加载。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[垃圾回收]]></title>
        <id>https://wang-y.github.io/post/lajihuishou</id>
        <link href="https://wang-y.github.io/post/lajihuishou">
        </link>
        <updated>2019-07-06T13:53:59.000Z</updated>
        <summary type="html"><![CDATA[<p>如果Java虚拟机创建的对象无论是否被使用都不会得到释放从而占满了所有的内存空间，那么在创建新的对象时，将会产生OutOfMemoryException。</p>
]]></summary>
        <content type="html"><![CDATA[<p>如果Java虚拟机创建的对象无论是否被使用都不会得到释放从而占满了所有的内存空间，那么在创建新的对象时，将会产生OutOfMemoryException。</p>
<!-- more -->
<p>所以Java虚拟机有一套自动内存管理机制，叫做垃圾回收机制。</p>
<p>对象的是否需要进行回收，需要进行判断，判断的方式有两种：</p>
<p><strong>引用计数法</strong></p>
<p>当对象每被引用一次时，其引用计数器加一；当其中一个引用失效时，其引用计数器减一，当对象的引用计数器值为零时，标记此对象可以被清除。</p>
<p>优点：</p>
<ul>
<li>判定效率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>当两个对象循环引用时，计数器便无法标记为0，于是导致两个对象不会被回收。</li>
</ul>
<p><strong>可达性分析</strong></p>
<p>从一个根节点向下搜索，搜索的路径被称作引用链，当一个对象到根节点没有任何引用链相连时，则证明此对象是不可达的，标记次对象可以被清除。</p>
<p>优点：</p>
<ul>
<li>更加精确和严谨，可以分析出循环数据结构相互引用的情况</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现比较复杂</li>
<li>需要分析大量数据，消耗大量时间</li>
<li>分析过程需要GC停顿（引用关系不能发生变化），即停顿所有Java执行线程（称为&quot;Stop The World&quot;，是垃圾回收重点关注的问题）</li>
</ul>
<p>可达性分析法中的根叫做GC Roots。</p>
<p>在Java中，能够当作GC Roots的有：</p>
<ul>
<li>VM Stack中Stack Frame的局部地变量表引用的对象</li>
<li>方法区/元空间中的静态属性引用的对象</li>
<li>方法区/元空间中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<p>目前所有的Java虚拟机中都采用可达性分析法来判断对象是否需要被清除。</p>
<h1 id="垃圾回收算法">垃圾回收算法</h1>
<h2 id="标记-清除算法">标记-清除算法</h2>
<p>首先遍历GC Roots标记出存活对象，然后再次遍历所有对象，将没有被标记为存活的对象清除。</p>
<p>缺点：效率低，且容易产生内存碎片，如果新的对象无法找到合适的连续空间进行存储，将会触发GC。</p>
<h2 id="复制算法">复制算法</h2>
<p>将内存区等分为两个区域，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。当活动区间被占满时，将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。在空间转换的同时垃圾对象被一次性清除。</p>
<p>优点：无内存碎片；</p>
<p>缺点：可用内存减少一半，降低性能。</p>
<h2 id="标记-整理算法">标记-整理算法</h2>
<p>首先遍历GC Roots标记出存活对象，然后再次遍历所有对象，移动存活对象按照内存地址依次排列，最后，将末端内存地址以后的内存全部回收。</p>
<p>优点：</p>
<ul>
<li>产生较少的内存碎片</li>
<li>消除了复制算法中内存减半额高额待见</li>
</ul>
<p>缺点：效率低</p>
<h1 id="垃圾收集器">垃圾收集器</h1>
<h2 id="serial-gc">Serial GC</h2>
<p>单线程串行垃圾收集器，新生代使用复制算法，老年代使用标记-整理算法。</p>
<p>Stop The Word时间长。</p>
<h2 id="parnew-gc">ParNew GC</h2>
<p>多线程串行垃圾收集器，Serial GC的多线程版本，新生代使用复制算法，老年代使用标记-整理算法。</p>
<p>Stop The Word时间相对Serial GC较短，但在单线程环境中不一定表现比Serial GC更好。</p>
<h2 id="parallel-scavenge-gc">Parallel Scavenge GC</h2>
<p>并行清除垃圾收集器，是一个新生代收集器，采用复制算法，其关注点并非尽可能的降低STW时间，而是旨在达到一个可以控制的吞吐量。</p>
<p>吞吐量指的是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。</p>
<h2 id="serial-old-gc">Serial Old GC</h2>
<p>单线程老年代串行垃圾收集器，Serial GC的老年代版本，是一个老年代收集器，老年代采用标记-整理算法。</p>
<h2 id="parallel-old-gc">Parallel Old GC</h2>
<p>并行清除老年代垃圾收集器，Parallel Scavenge GC的老年代版本，是一个老年代收集器，使用多线程和标记-整理算法。</p>
<h2 id="concurrent-mark-sweep-gc">Concurrent Mark Sweep GC</h2>
<p>并发标记清除垃圾收集器，是使用标记-清除算法的老年代收集器。</p>
<p>工作时主要分为四个步骤：</p>
<ol>
<li>初始标记(单线程，STW)</li>
<li>并发标记(同用户线程一起工作)</li>
<li>重新标记(并行，STW)</li>
<li>并发清除(同用户线程一起工作)</li>
</ol>
<p>问题：</p>
<ul>
<li>CPU资源敏感</li>
<li>无法处理浮动垃圾</li>
<li>易产生内存碎片</li>
</ul>
<h2 id="garbage-first-gc">Garbage First GC</h2>
<p>简称G1垃圾收集器，非实时收集器。</p>
<p>特点：</p>
<ul>
<li>并行并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ul>
<p>工作时分为四个步骤：</p>
<ol>
<li>初始标记(单线程，STW)</li>
<li>并发标记(同用户线程一起工作)</li>
<li>最终标记(并行)</li>
<li>筛选回收(并行)</li>
</ol>
<p>在G1垃圾收集器中，采用了全新的内存布局，将Heap分成了一块块大小相等的Heap Region，一般在2000多块，Region在逻辑上时连续的，每个Region都会被打上唯一分代标记(eden,survivor,old)。在逻辑上，eden regions构成Eden空间，survivor regions构成Survivor空间，old regions构成了old 空间。</p>
<p>在并发标记时，G1会确定堆中对象的存活情况，标记完成后，G1知道哪些regions空闲空间多(可回收对象多)，优先回收这些空的regions，释放出大量的空闲空间。</p>
<h1 id="内存分配策略">内存分配策略</h1>
<ul>
<li>对象优先在 Young Gen 的 Eden Space 分配</li>
<li>大对象直接进入 Old Gen</li>
<li>长期存活对象进入 Old Gen (对象在Eden区出生且经过第一次GC后，仍然存活，将其放入Survivor的活动区域中，年龄记为1，再次GC后，存活的对象从活动区域转换到原先的空闲区域，并且年龄加一，如此反复，直至对象年龄达到指定年龄，进入Old Gen)</li>
<li>动态对象年龄判定(当Survivor中相同年龄所有对象的大小已经达到了或者超过了Survivor的一半，那么年龄大于等于该年龄的对象可以直接进入Old Gen)</li>
<li>空间分配担保</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存模型]]></title>
        <id>https://wang-y.github.io/post/jvmneicunmoxing</id>
        <link href="https://wang-y.github.io/post/jvmneicunmoxing">
        </link>
        <updated>2019-07-06T04:37:02.000Z</updated>
        <summary type="html"><![CDATA[<p>Java RunTime Data Area(Java 运行时数据区) 分为:</p>
<ul>
<li>Java Heap(Java堆)</li>
<li>Method Area(方法区) (Java 8 之前)</li>
<li>Meta Space(元空间) (Java 8 之后)</li>
<li>VM Stack(虚拟机栈)</li>
<li>Native Methiod Stack(本地方法栈)</li>
<li>Program Counter Register(程序计数器)。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>Java RunTime Data Area(Java 运行时数据区) 分为:</p>
<ul>
<li>Java Heap(Java堆)</li>
<li>Method Area(方法区) (Java 8 之前)</li>
<li>Meta Space(元空间) (Java 8 之后)</li>
<li>VM Stack(虚拟机栈)</li>
<li>Native Methiod Stack(本地方法栈)</li>
<li>Program Counter Register(程序计数器)。</li>
</ul>
<!-- more --> 
<p><img src="https://wang-y.github.io/post-images/1562387893493.png" alt=""></p>
<h1 id="java-heap">Java Heap</h1>
<p>Java创建的所有引用对象类型都存储在Heap中，所以此区域是所有线程共享的。</p>
<p>Heap中有分为:</p>
<ul>
<li>Old Gen(老年代)</li>
<li>Young Gen(新生代)</li>
<li>Eden Space(伊甸区)</li>
<li>Survivor Space(幸存者区)
<ul>
<li>From</li>
<li>To</li>
</ul>
</li>
</ul>
<p>因所有引用对象类型都存储在Heap区中，如果对象始终存在而不被清除，那么Heap内存将会被占满，导致内存溢出，所以Heap是垃圾收集的重点区域。</p>
<h1 id="method-areaperm-gen">Method Area/Perm Gen</h1>
<p>Java中被加载的类信息、常量、静态变量、即时编译器编译后的代码都存储在此区域中，所有此区域是所有线程共享的。</p>
<p>类信息包括：</p>
<ul>
<li>完整有效名称（全名=包名.类名）</li>
<li>直接父类的有效名称（java.lang.Object除外)</li>
<li>类的修饰符</li>
<li>接口的有序列表</li>
<li>域(field)信息</li>
<li>方法(method)信息</li>
</ul>
<p>常量及静态变量：</p>
<ul>
<li>static final 修饰的常量</li>
<li>static 修饰的变量</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>对于八种基本数据类型的静态变量会直接在方法区中开辟空间，并将其对应的值存储在方法区中</li>
<li>对于引用类型的静态变量如果未用new关键字为引用类型的静态变量分配对象（如: static Object obj;）那么对象的引用obj会存储在方法区中，并为其指定默认值null;</li>
<li>对于引用类型的静态变量如果用new关键字为引用类型的静态变量分配对象（如: static Person person = new Person();）,那么对象的引用person 会存储在方法区中，并且该对象在堆中的地址也会存储在方法区中（注意此时静态变量只存储了对象的堆地址，而对象本身仍在堆内存中）</li>
</ul>
<p>Method Area也经常被称作Non-heap(非堆)，但是在Hotspot中，其定义了Perm Gen(持久代)(仅在Hotspot中有持久代这个概念)，以此替代Method Area，也就是说在Hotspot中在物理上Method Area存在于Heap中的Perm Gen中，但是从逻辑上来讲，Method Area与Heap的概念还是互相独立的。</p>
<p>在Java7之前，字符串常量池和运行时常量池都存放在Method Area中。
到Java7时，字符串常量池被移到了Heap中。</p>
<p>Method Area也需要进行垃圾收集。</p>
<h1 id="meta-space">Meta Space</h1>
<p>Java8之后，移除了Method Area的概念，引入了新的Meta Space概念，这使得在原先从物理上占用Heap内存的Perm Gen的空间得到了释放，新的Meta Space将直接使用本地内存，使得类元数据只受到可用的本地内存限制(容量取决于是32位或是64位操作系统的可用虚拟内存大小)</p>
<p>在Java8之后，运行常量池被移到了Meta Space中，字符串常量池依然存放于堆中。</p>
<p>Meta Space也需要进行垃圾收集。</p>
<h1 id="vm-stack">VM Stack</h1>
<p>当方法被执行时，会同时创建一个Stack Frame(栈帧)。</p>
<p>Stack Frame内会记录:</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口</li>
</ul>
<p>每一个方法的执行，就代表这一个Stack Frame从入栈到出栈的过程，VM Stack被执行这个方法的线程单独持有，是私有的。</p>
<p>VM Stack的大小可以是固定的，也可以是动态调整的，如果大小被固定，一旦线程需要一个比较固定大小更大的VM Stack，将会发生 StackOverflowException；如果是动态调整的大小，一旦在动态拓展时没有足够的内存或者系统没有系统没有足够的内存为新线程创建Stack，将会发生OutOfMemoryExcption；</p>
<h1 id="native-methiod-stack">Native Methiod Stack</h1>
<p>本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、方法出口。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间。</p>
<p>也会抛出StackOverFlowError和OutOfMemoryError异常。</p>
<h1 id="program-counter-register">Program Counter Register</h1>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>Program Counter Register 正是这个用于记录当前线程正在执行的字节码的行号指示器。</p>
<p>此区域是Java规范中唯一没有规定任何OutOfMemoryExcption的区域。</p>
<p>如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p>
]]></content>
    </entry>
</feed>